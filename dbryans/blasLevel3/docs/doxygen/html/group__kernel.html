<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>BLAS Level 3: kernel</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">kernel</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#gaaf90c3693ca962bad25251ee55a67fe1">M_KERNEL_C</a>&#160;&#160;&#160;2</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number of rows to process by core kernel for single precision complex  <a href="#gaaf90c3693ca962bad25251ee55a67fe1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga416d1673ae180f28ea78c1542381ac6f">N_KERNEL_C</a>&#160;&#160;&#160;4</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number of columns to process by core kernel for single precision complex  <a href="#ga416d1673ae180f28ea78c1542381ac6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga44a73e6713b1693e4d4b8788e8a8715e">KPARTITION_C</a>&#160;&#160;&#160;512</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">partition in k dimension for single precision complex  <a href="#ga44a73e6713b1693e4d4b8788e8a8715e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#gab6eb83c9d6fd9fa003cdb33912d14231">NUMAPANELS_C</a>&#160;&#160;&#160;32</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number of panels of A to keep in MCMS/L2 for single precision complex  <a href="#gab6eb83c9d6fd9fa003cdb33912d14231"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#gac631d3a0c661ca5048e4c4b49e349252">NUMBPANELS_C</a>&#160;&#160;&#160;4</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number of panels of B to keep in MCMS for single precision complex  <a href="#gac631d3a0c661ca5048e4c4b49e349252"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#gababe49defc3839b7c4c6b3c5e338115d">MPARTITION_C</a>&#160;&#160;&#160;(NUMAPANELS_C*M_KERNEL_C)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">partition in m dimension for single precision complex (MPARTITION_C &lt;= KPARTITION_C)  <a href="#gababe49defc3839b7c4c6b3c5e338115d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga82e046a41a629a2d622315ce11d8af2a">NPARTITION_C</a>&#160;&#160;&#160;(NUMBPANELS_C*N_KERNEL_C)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">partition in n dimension for single precision complex  <a href="#ga82e046a41a629a2d622315ce11d8af2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga64d3354cacd9bd5d98c0e1d77f022bd3">M_KERNEL_D</a>&#160;&#160;&#160;4</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number of rows to process by core kernel for double precision  <a href="#ga64d3354cacd9bd5d98c0e1d77f022bd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga571fb3d37c3c42b647fc792408c9de2a">N_KERNEL_D</a>&#160;&#160;&#160;4</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number of columns to process by core kernel for double precision  <a href="#ga571fb3d37c3c42b647fc792408c9de2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#gaf14b648084a41c2b1953a56ae4e0b16f">KPARTITION_D</a>&#160;&#160;&#160;256</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">partition in k dimension for double precision  <a href="#gaf14b648084a41c2b1953a56ae4e0b16f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#gafb96d4ad03ff2ff1a4d020d9323a9d96">NUMAPANELS_D</a>&#160;&#160;&#160;32</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number of panels of A to keep in MCMS/L2 for double precision  <a href="#gafb96d4ad03ff2ff1a4d020d9323a9d96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga99b8c99ea3d396d9a2e36fbc4c8827f4">NUMBPANELS_D</a>&#160;&#160;&#160;8</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number of panels of B to keep in MCMS for double precision  <a href="#ga99b8c99ea3d396d9a2e36fbc4c8827f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga3fbb6b66d03e1f6e28a92ade7c27cf43">MPARTITION_D</a>&#160;&#160;&#160;(NUMAPANELS_D*M_KERNEL_D)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">partition in m dimension for double precision (MPARTITION_D &lt;= KPARTITION_D)  <a href="#ga3fbb6b66d03e1f6e28a92ade7c27cf43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga5ac559036bc7631c0d691bc399151b77">NPARTITION_D</a>&#160;&#160;&#160;(NUMBPANELS_D*N_KERNEL_D)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">partition in n dimension for double precision  <a href="#ga5ac559036bc7631c0d691bc399151b77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga38dded6e0b873d8474d16f5cce32b9c4">M_KERNEL_S</a>&#160;&#160;&#160;4</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number of rows to process by core kernel for single precision  <a href="#ga38dded6e0b873d8474d16f5cce32b9c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#gaf8005c932c5f5766135ad3f806e2ca81">N_KERNEL_S</a>&#160;&#160;&#160;8</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number of columns to process by core kernel for single precision  <a href="#gaf8005c932c5f5766135ad3f806e2ca81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga064e9a858defc8ddf47a94e1b0176867">KPARTITION_S</a>&#160;&#160;&#160;512</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">partition in k dimension for single precision  <a href="#ga064e9a858defc8ddf47a94e1b0176867"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga95cdd25ea213530aacecb0ae4c06da39">NUMAPANELS_S</a>&#160;&#160;&#160;32</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number of panels of A to keep in MCMS/L2 for single precision  <a href="#ga95cdd25ea213530aacecb0ae4c06da39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#gababf10a8a7298c7d2c8729fef5f4168b">NUMBPANELS_S</a>&#160;&#160;&#160;4</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number of panels of B to keep in MCMS for single precision  <a href="#gababf10a8a7298c7d2c8729fef5f4168b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#gaf5ed0c47d390e225120f61b41fcb301c">MPARTITION_S</a>&#160;&#160;&#160;(NUMAPANELS_S*M_KERNEL_S)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">partition in m dimension for single precision (MPARTITION_S &lt;= KPARTITION_S)  <a href="#gaf5ed0c47d390e225120f61b41fcb301c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga663620ddec1ccb5d0c9ed5aa584bb473">NPARTITION_S</a>&#160;&#160;&#160;(NUMBPANELS_S*N_KERNEL_S)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">partition in n dimension for single precision  <a href="#ga663620ddec1ccb5d0c9ed5aa584bb473"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga1d5a064cd31d54b033950b00b5d30558">M_KERNEL_Z</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number of rows to process by core kernel for double precision complex  <a href="#ga1d5a064cd31d54b033950b00b5d30558"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga5ca6f1ec823382afb58afa4da1ecbc77">N_KERNEL_Z</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number of columns to process by core kernel for double precision complex  <a href="#ga5ca6f1ec823382afb58afa4da1ecbc77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga163b07b1ace6e6583947a366b9cb2b11">KPARTITION_Z</a>&#160;&#160;&#160;512</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">partition in k dimension for double precision complex  <a href="#ga163b07b1ace6e6583947a366b9cb2b11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga27697f4b514d4af26ad2fa0071a984de">NUMAPANELS_Z</a>&#160;&#160;&#160;32</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number of panels of A to keep in MCMS/L2 for double precision complex  <a href="#ga27697f4b514d4af26ad2fa0071a984de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga27ecd772a7f65be627d40f1ce7bf28e1">NUMBPANELS_Z</a>&#160;&#160;&#160;8</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">number of panels of B to keep in MCMS for double precision complex  <a href="#ga27ecd772a7f65be627d40f1ce7bf28e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga1cb780051c1f24665e315024e5879df0">MPARTITION_Z</a>&#160;&#160;&#160;(NUMAPANELS_Z*M_KERNEL_Z)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">partition in m dimension for double precision complex (MPARTITION_Z &lt;= KPARTITION_Z)  <a href="#ga1cb780051c1f24665e315024e5879df0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga6b875b0eb12e72ecbd35c8824890652d">NPARTITION_Z</a>&#160;&#160;&#160;(NUMBPANELS_Z*N_KERNEL_Z)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">partition in n dimension for double precision complex  <a href="#ga6b875b0eb12e72ecbd35c8824890652d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga8df722b37944c5219054285fc703721e">cgemmKernel</a> (const <a class="el" href="structcomplex.html">complex</a> *pA, const <a class="el" href="structcomplex.html">complex</a> *pB, <a class="el" href="structcomplex.html">complex</a> *pC, const <a class="el" href="structcomplex.html">complex</a> a, const int k, const int stepC)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core matrix multiplication routine; performs C += a*A*B. A is 2xk matrix of complex numbers; B is kx4 matrix of complex numbers; a is scalar multiplicative constant; C is 2x4 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major.  <a href="#ga8df722b37944c5219054285fc703721e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#gab0a20f8becde0a9becdc4c175983baee">cgemmKernelFlexSave</a> (const <a class="el" href="structcomplex.html">complex</a> *pA, const <a class="el" href="structcomplex.html">complex</a> *pB, <a class="el" href="structcomplex.html">complex</a> *pC, const <a class="el" href="structcomplex.html">complex</a> a, const int k, const int stepC, const int saveLoc, const int flagisN)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core matrix multiplication routine; performs C += a*A*B. This particular functions flexible saving of the 2 x 4 output. It can save as 4 x 2 transposed output. In addition, it can also save only the lower/upper triangular part of the output. A is 2xk matrix of complex numbers; B is kx4 matrix of complex numbers; a is scalar multiplicative constant; C is 2x4 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major.  <a href="#gab0a20f8becde0a9becdc4c175983baee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#gaee93ce96268d4b0247f234b44de51a19">cgemmKernelNoReadFlexSave</a> (const <a class="el" href="structcomplex.html">complex</a> *pA, const <a class="el" href="structcomplex.html">complex</a> *pB, <a class="el" href="structcomplex.html">complex</a> *pC, const <a class="el" href="structcomplex.html">complex</a> a, const int k, const int stepC, const int saveLoc, const int flagisN)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core matrix multiplication routine; performs C = a*A*B. This particular functions flexible saving of the 2 x 4 output. It can save as 4 x 2 transposed output. In addition, it can also save only the lower/upper triangular part of the output. This variation of the kernel do not read from C. A is 2xk matrix of complex numbers; B is kx4 matrix of complex numbers; a is scalar multiplicative constant; C is 2x4 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major.  <a href="#gaee93ce96268d4b0247f234b44de51a19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga5554cbae0ad254ae6d3cb38e06e38d15">ctrsmKernel</a> (const <a class="el" href="structcomplex.html">complex</a> *pA, <a class="el" href="structcomplex.html">complex</a> *pB, <a class="el" href="structcomplex.html">complex</a> *pC, <a class="el" href="structcomplex.html">complex</a> *pBHat, const int k, const int stepC, const int flagisN, const int flagisL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core traingular matrix inversionroutine; First performs C += A*B either to or from followed by C=A^{-1}(2,2)*B. That is it accumulates the necessary C and finalluy performs inverse multiplications by a 2x2 matrix. The 2x2 matrix was already inverted in the data movement routine and hence. This kernel only performs the multplications. The multiplication can be pre or post depending on whether we are saving the transpose form of the output or not. Also note that the inverted matrix can be lower or upper triangular. A is 2xk matrix of complex numbers; B os kx4 matrix of complex numbers; C is 2x4 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major.  <a href="#ga5554cbae0ad254ae6d3cb38e06e38d15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga55c79885a68afa248c5ed80508f6e447">dgemmKernel</a> (const double *pA, const double *pB, double *pC, const double a, const int k, const int stepC)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core matrix multiplication routine; performs C += a*A*B. A is 4xk matrix of doubles; B is kx4 matrix of doubles; a is scalar multiplicative constant; C is 4x4 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major.  <a href="#ga55c79885a68afa248c5ed80508f6e447"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga24187bdb447e6f5b0918e72d2faed86a">dgemmKernelFlexSave</a> (const double *pA, const double *pB, double *pC, const double a, const int k, const int stepC, const int saveLoc, const int flagisN)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core matrix multiplication routine; performs C += a*A*B. This particular functions flexible saving of the 4 x 4 output. It can save as 4 x 4 transposed output. In addition, it can also save only the lower/upper triangular part of the output. A is 4xk matrix of doubles; B is kx4 matrix of doubles; a is scalar multiplicative constant; C is 4x4 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major.  <a href="#ga24187bdb447e6f5b0918e72d2faed86a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#gab5d13df050308fd6863f44a09ee2f234">dgemmKernelNoReadFlexSave</a> (const double *pA, const double *pB, double *pC, const double a, const int k, const int stepC, const int saveLoc, const int flagisN)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core matrix multiplication routine; performs C = a*A*B. This particular functions flexible saving of the 4 x 4 output. It can save as 4 x 4 transposed output. In addition, it can also save only the lower/upper triangular part of the output. This variation of the kernel do not read from C. A is 4xk matrix of doubles; B is kx4 matrix of doubles; a is scalar multiplicative constant; C is 4x4 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major.  <a href="#gab5d13df050308fd6863f44a09ee2f234"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#gaddf8875bd5fffbffbe5f3a579cd8e00e">dtrsmKernel</a> (const double *pA, double *pB, double *pC, double *pBHat, const int k, const int stepC, const int flagisN, const int flagisL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core traingular matrix inversionroutine; First performs C += A*B either to or from followed by C=A^{-1}(4,4)*B. That is it accumulates the necessary C and finalluy performs inverse multiplications by a 4x4 matrix. The 4x4 matrix was already inverted in the data movement routine and hence. This kernel only performs the multplications. The multiplication can be pre or post depending on whether we are saving the transpose form of the output or not. Also note that the inverted matrix can be lower or upper triangular. A is 4xk matrix of reals; B os kx4 matrix of reals; C is 4x4 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major.  <a href="#gaddf8875bd5fffbffbe5f3a579cd8e00e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#gabcbb885da92272bf4838e80fe70fe9bc">sgemmKernel</a> (const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *pA, const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *pB, <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *pC, const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> a, const int k, const int stepC)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core matrix multiplication routine; performs C += a*A*B. A is 4xk matrix of reals; B is kx8 matrix of reals; a is scalar multiplicative constant; C is 4x8 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major.  <a href="#gabcbb885da92272bf4838e80fe70fe9bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga8a09abfb6e1e1c12b71d604a86324184">sgemmKernelFlexSave</a> (const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *pA, const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *pB, <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *pC, const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> a, const int k, const int stepC, const int saveLoc, const int flagisN)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core matrix multiplication routine; performs C += a*A*B. This particular functions flexible saving of the 4 x 8 output. It can save as 8 x 4 transposed output. In addition, it can also save only the lower/upper triangular part of the output. A is 4xk matrix of reals; B is kx8 matrix of reals; a is scalar multiplicative constant; C is 4x8 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major.  <a href="#ga8a09abfb6e1e1c12b71d604a86324184"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#gae3c3e56093f7526255e4be710216030c">sgemmKernelNoReadFlexSave</a> (const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *pA, const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *pB, <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *pC, const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> a, const int k, const int stepC, const int saveLoc, const int flagisN)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core matrix multiplication routine; performs C = a*A*B. This particular functions flexible saving of the 4 x 8 output. It can save as 8 x 4 transposed output. In addition, it can also save only the lower/upper triangular part of the output. This variation of the kernel do not read from C. A is 4xk matrix of reals; B is kx8 matrix of reals; a is scalar multiplicative constant; C is 4x8 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major.  <a href="#gae3c3e56093f7526255e4be710216030c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga27623ba25b81fef7c11883d4c25bb929">strsmKernel</a> (const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *pA, <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *pB, <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *pC, <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *pBHat, const int k, const int stepC, const int flagisN, const int flagisL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core traingular matrix inversionroutine; First performs C += A*B either to or from followed by C=A^{-1}(4,4)*B. That is it accumulates the necessary C and finalluy performs inverse multiplications by a 4x4 matrix. The 4x4 matrix was already inverted in the data movement routine and hence. This kernel only performs the multplications. The multiplication can be pre or post depending on whether we are saving the transpose form of the output or not. Also note that the inverted matrix can be lower or upper triangular. A is 4xk matrix of reals; B os kx8 matrix of reals; C is 4x8 matrix; It is actually a sub-matrix of larger marger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major.  <a href="#ga27623ba25b81fef7c11883d4c25bb929"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga86dd34473d096e9004e2116edfc1371e">zgemmKernel</a> (const <a class="el" href="structdoublecomplex.html">doublecomplex</a> *pA, const <a class="el" href="structdoublecomplex.html">doublecomplex</a> *pB, <a class="el" href="structdoublecomplex.html">doublecomplex</a> *pC, const <a class="el" href="structdoublecomplex.html">doublecomplex</a> a, const int k, const int stepC)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core matrix multiplication routine; performs C += a*A*B. A is 4xk matrix of doublecomplex numbers; B os kx8 matrix of doublecomplex numbers; a is scalar multiplicative constant; C is 4x8 matrix; It is actually a sub-matrix of larger marger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major.  <a href="#ga86dd34473d096e9004e2116edfc1371e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga18c67e16636b6df862fe73275dd409b7">zgemmKernelFlexSave</a> (const <a class="el" href="structdoublecomplex.html">doublecomplex</a> *pA, const <a class="el" href="structdoublecomplex.html">doublecomplex</a> *pB, <a class="el" href="structdoublecomplex.html">doublecomplex</a> *pC, const <a class="el" href="structdoublecomplex.html">doublecomplex</a> a, const int k, const int stepC, const int saveLoc, const int flagisN)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core matrix multiplication routine; performs C += a*A*B. This particular functions flexible saving of the 4 x 8 output. It can save as 8 x 4 transposed ouput. In addition, it can also save only the lower/upper traingular part of the output. A is 4xk matrix of doublecomplex numbers; B os kx8 matrix of doublecomplex numbers; a is scalar multiplicative constant; C is 4x8 matrix; It is actually a sub-matrix of larger marger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major.  <a href="#ga18c67e16636b6df862fe73275dd409b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#ga5b875b49e9822c689f8983d139f39e41">zgemmKernelNoReadFlexSave</a> (const <a class="el" href="structdoublecomplex.html">doublecomplex</a> *pA, const <a class="el" href="structdoublecomplex.html">doublecomplex</a> *pB, <a class="el" href="structdoublecomplex.html">doublecomplex</a> *pC, const <a class="el" href="structdoublecomplex.html">doublecomplex</a> a, const int k, const int stepC, const int saveLoc, const int flagisN)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core matrix multiplication routine; performs C = a*A*B. This particular functions flexible saving of the 4 x 8 output. It can save as 8 x 4 transposed ouput. In addition, it can also save only the lower/upper traingular part of the output. This variation of the kernel do not read from C. A is 4xk matrix of doublecomplex numbers; B os kx8 matrix of doublecomplex numbers; a is scalar multiplicative constant; C is 4x8 matrix; It is actually a sub-matrix of larger marger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major.  <a href="#ga5b875b49e9822c689f8983d139f39e41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html#gaf99350e21fb4fd8e5486fb9be9b79564">ztrsmKernel</a> (const <a class="el" href="structdoublecomplex.html">doublecomplex</a> *pA, <a class="el" href="structdoublecomplex.html">doublecomplex</a> *pB, <a class="el" href="structdoublecomplex.html">doublecomplex</a> *pC, <a class="el" href="structdoublecomplex.html">doublecomplex</a> *pBHat, const int k, const int stepC, const int flagisN, const int flagisL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Core traingular matrix inversionroutine; First performs C += A*B either to or from followed by C=A^{-1}(1,1)*B. That is it accumulates the necessary C and finalluy performs inverse multiplications by a 1x1 matrix. The 1x1 matrix was already inverted in the data movement routine and hence. This kernel only performs the multplications. The multiplication can be pre or post depending on whether we are saving the transpose form of the output or not. Also note that the inverted matrix can be lower or upper triangular. A is 1xk matrix of complex numbers; B os kx1 matrix of complex numbers; C is 1x1 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major.  <a href="#gaf99350e21fb4fd8e5486fb9be9b79564"></a><br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga44a73e6713b1693e4d4b8788e8a8715e"></a><!-- doxytag: member="defCC66.h::KPARTITION_C" ref="ga44a73e6713b1693e4d4b8788e8a8715e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KPARTITION_C&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>partition in k dimension for single precision complex </p>

<p>Definition at line <a class="el" href="def_c_c66_8h_source.html#l00059">59</a> of file <a class="el" href="def_c_c66_8h_source.html">defCC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_ctrmm_8c_source.html#l00094">arrangeDataLTACtrmm()</a>, <a class="el" href="data_move_ctrsm_8c_source.html#l00180">arrangeDataLTACtrsm()</a>, <a class="el" href="data_move_ctrmm_8c_source.html#l00192">arrangeDataUTACtrmm()</a>, <a class="el" href="data_move_ctrsm_8c_source.html#l00262">arrangeDataUTACtrsm()</a>, <a class="el" href="ctrsm_kernel_8c_source.html#l00047">ctrsmKernel()</a>, <a class="el" href="data_move_cgemm_8c_source.html#l00114">dataMoveACgemm()</a>, <a class="el" href="data_move_cgemm_8c_source.html#l00183">dataMoveAHCgemm()</a>, <a class="el" href="data_move_cgemm_8c_source.html#l00149">dataMoveATCgemm()</a>, and <a class="el" href="data_move_cgemm_8c_source.html#l00089">dataMoveBCgemm()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf14b648084a41c2b1953a56ae4e0b16f"></a><!-- doxytag: member="defDC66.h::KPARTITION_D" ref="gaf14b648084a41c2b1953a56ae4e0b16f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KPARTITION_D&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>partition in k dimension for double precision </p>

<p>Definition at line <a class="el" href="def_d_c66_8h_source.html#l00059">59</a> of file <a class="el" href="def_d_c66_8h_source.html">defDC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_dtrmm_8c_source.html#l00090">arrangeDataLTADtrmm()</a>, <a class="el" href="data_move_dtrsm_8c_source.html#l00225">arrangeDataLTADtrsm()</a>, <a class="el" href="data_move_dtrmm_8c_source.html#l00184">arrangeDataUTADtrmm()</a>, <a class="el" href="data_move_dtrsm_8c_source.html#l00307">arrangeDataUTADtrsm()</a>, <a class="el" href="data_move_dgemm_8c_source.html#l00118">dataMoveADgemm()</a>, <a class="el" href="data_move_dgemm_8c_source.html#l00156">dataMoveATDgemm()</a>, <a class="el" href="data_move_dgemm_8c_source.html#l00067">dataMoveBDgemm()</a>, and <a class="el" href="dtrsm_kernel_8c_source.html#l00048">dtrsmKernel()</a>.</p>

</div>
</div>
<a class="anchor" id="ga064e9a858defc8ddf47a94e1b0176867"></a><!-- doxytag: member="defSC66.h::KPARTITION_S" ref="ga064e9a858defc8ddf47a94e1b0176867" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KPARTITION_S&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>partition in k dimension for single precision </p>

<p>Definition at line <a class="el" href="def_s_c66_8h_source.html#l00059">59</a> of file <a class="el" href="def_s_c66_8h_source.html">defSC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_strmm_8c_source.html#l00090">arrangeDataLTAStrmm()</a>, <a class="el" href="data_move_strsm_8c_source.html#l00225">arrangeDataLTAStrsm()</a>, <a class="el" href="data_move_strmm_8c_source.html#l00184">arrangeDataUTAStrmm()</a>, <a class="el" href="data_move_strsm_8c_source.html#l00307">arrangeDataUTAStrsm()</a>, <a class="el" href="data_move_sgemm_8c_source.html#l00147">dataMoveASgemm()</a>, <a class="el" href="data_move_sgemm_8c_source.html#l00185">dataMoveATSgemm()</a>, <a class="el" href="data_move_sgemm_8c_source.html#l00071">dataMoveBSgemm()</a>, and <a class="el" href="strsm_kernel_8c_source.html#l00046">strsmKernel()</a>.</p>

</div>
</div>
<a class="anchor" id="ga163b07b1ace6e6583947a366b9cb2b11"></a><!-- doxytag: member="defZC66.h::KPARTITION_Z" ref="ga163b07b1ace6e6583947a366b9cb2b11" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KPARTITION_Z&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>partition in k dimension for double precision complex </p>

<p>Definition at line <a class="el" href="def_z_c66_8h_source.html#l00059">59</a> of file <a class="el" href="def_z_c66_8h_source.html">defZC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_ztrmm_8c_source.html#l00094">arrangeDataLTAZtrmm()</a>, <a class="el" href="data_move_ztrsm_8c_source.html#l00098">arrangeDataLTAZtrsm()</a>, <a class="el" href="data_move_ztrmm_8c_source.html#l00192">arrangeDataUTAZtrmm()</a>, <a class="el" href="data_move_ztrsm_8c_source.html#l00208">arrangeDataUTAZtrsm()</a>, <a class="el" href="data_move_zgemm_8c_source.html#l00139">dataMoveAHZgemm()</a>, <a class="el" href="data_move_zgemm_8c_source.html#l00118">dataMoveATZgemm()</a>, and <a class="el" href="data_move_zgemm_8c_source.html#l00095">dataMoveAZgemm()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaf90c3693ca962bad25251ee55a67fe1"></a><!-- doxytag: member="defCC66.h::M_KERNEL_C" ref="gaaf90c3693ca962bad25251ee55a67fe1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M_KERNEL_C&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of rows to process by core kernel for single precision complex </p>

<p>Definition at line <a class="el" href="def_c_c66_8h_source.html#l00050">50</a> of file <a class="el" href="def_c_c66_8h_source.html">defCC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_ctrsm_8c_source.html#l00221">arrangeDataLACtrsm()</a>, <a class="el" href="data_move_ctrsm_8c_source.html#l00180">arrangeDataLTACtrsm()</a>, <a class="el" href="data_move_ctrsm_8c_source.html#l00139">arrangeDataUACtrsm()</a>, <a class="el" href="data_move_ctrsm_8c_source.html#l00262">arrangeDataUTACtrsm()</a>, and <a class="el" href="ctrsm_kernel_8c_source.html#l00047">ctrsmKernel()</a>.</p>

</div>
</div>
<a class="anchor" id="ga64d3354cacd9bd5d98c0e1d77f022bd3"></a><!-- doxytag: member="defDC66.h::M_KERNEL_D" ref="ga64d3354cacd9bd5d98c0e1d77f022bd3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M_KERNEL_D&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of rows to process by core kernel for double precision </p>

<p>Definition at line <a class="el" href="def_d_c66_8h_source.html#l00050">50</a> of file <a class="el" href="def_d_c66_8h_source.html">defDC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_dtrsm_8c_source.html#l00266">arrangeDataLADtrsm()</a>, <a class="el" href="data_move_dtrsm_8c_source.html#l00225">arrangeDataLTADtrsm()</a>, <a class="el" href="data_move_dtrsm_8c_source.html#l00184">arrangeDataUADtrsm()</a>, <a class="el" href="data_move_dtrsm_8c_source.html#l00307">arrangeDataUTADtrsm()</a>, and <a class="el" href="dtrsm_kernel_8c_source.html#l00048">dtrsmKernel()</a>.</p>

</div>
</div>
<a class="anchor" id="ga38dded6e0b873d8474d16f5cce32b9c4"></a><!-- doxytag: member="defSC66.h::M_KERNEL_S" ref="ga38dded6e0b873d8474d16f5cce32b9c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M_KERNEL_S&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of rows to process by core kernel for single precision </p>

<p>Definition at line <a class="el" href="def_s_c66_8h_source.html#l00050">50</a> of file <a class="el" href="def_s_c66_8h_source.html">defSC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_strsm_8c_source.html#l00266">arrangeDataLAStrsm()</a>, <a class="el" href="data_move_strsm_8c_source.html#l00225">arrangeDataLTAStrsm()</a>, <a class="el" href="data_move_strsm_8c_source.html#l00184">arrangeDataUAStrsm()</a>, <a class="el" href="data_move_strsm_8c_source.html#l00307">arrangeDataUTAStrsm()</a>, and <a class="el" href="strsm_kernel_8c_source.html#l00046">strsmKernel()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1d5a064cd31d54b033950b00b5d30558"></a><!-- doxytag: member="defZC66.h::M_KERNEL_Z" ref="ga1d5a064cd31d54b033950b00b5d30558" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M_KERNEL_Z&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of rows to process by core kernel for double precision complex </p>

<p>Definition at line <a class="el" href="def_z_c66_8h_source.html#l00050">50</a> of file <a class="el" href="def_z_c66_8h_source.html">defZC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_ztrsm_8c_source.html#l00153">arrangeDataLAZtrsm()</a>, <a class="el" href="data_move_ztrsm_8c_source.html#l00098">arrangeDataLTAZtrsm()</a>, <a class="el" href="data_move_ztrsm_8c_source.html#l00043">arrangeDataUAZtrsm()</a>, <a class="el" href="data_move_ztrsm_8c_source.html#l00208">arrangeDataUTAZtrsm()</a>, and <a class="el" href="ztrsm_kernel_8c_source.html#l00049">ztrsmKernel()</a>.</p>

</div>
</div>
<a class="anchor" id="gababe49defc3839b7c4c6b3c5e338115d"></a><!-- doxytag: member="defCC66.h::MPARTITION_C" ref="gababe49defc3839b7c4c6b3c5e338115d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPARTITION_C&#160;&#160;&#160;(NUMAPANELS_C*M_KERNEL_C)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>partition in m dimension for single precision complex (MPARTITION_C &lt;= KPARTITION_C) </p>

<p>Definition at line <a class="el" href="def_c_c66_8h_source.html#l00072">72</a> of file <a class="el" href="def_c_c66_8h_source.html">defCC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_ctrmm_8c_source.html#l00143">arrangeDataLACtrmm()</a>, <a class="el" href="data_move_ctrsm_8c_source.html#l00221">arrangeDataLACtrsm()</a>, <a class="el" href="data_move_ctrmm_8c_source.html#l00045">arrangeDataUACtrmm()</a>, and <a class="el" href="data_move_ctrsm_8c_source.html#l00139">arrangeDataUACtrsm()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3fbb6b66d03e1f6e28a92ade7c27cf43"></a><!-- doxytag: member="defDC66.h::MPARTITION_D" ref="ga3fbb6b66d03e1f6e28a92ade7c27cf43" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPARTITION_D&#160;&#160;&#160;(NUMAPANELS_D*M_KERNEL_D)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>partition in m dimension for double precision (MPARTITION_D &lt;= KPARTITION_D) </p>

<p>Definition at line <a class="el" href="def_d_c66_8h_source.html#l00072">72</a> of file <a class="el" href="def_d_c66_8h_source.html">defDC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_dtrmm_8c_source.html#l00137">arrangeDataLADtrmm()</a>, <a class="el" href="data_move_dtrsm_8c_source.html#l00266">arrangeDataLADtrsm()</a>, <a class="el" href="data_move_dtrmm_8c_source.html#l00043">arrangeDataUADtrmm()</a>, and <a class="el" href="data_move_dtrsm_8c_source.html#l00184">arrangeDataUADtrsm()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf5ed0c47d390e225120f61b41fcb301c"></a><!-- doxytag: member="defSC66.h::MPARTITION_S" ref="gaf5ed0c47d390e225120f61b41fcb301c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPARTITION_S&#160;&#160;&#160;(NUMAPANELS_S*M_KERNEL_S)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>partition in m dimension for single precision (MPARTITION_S &lt;= KPARTITION_S) </p>

<p>Definition at line <a class="el" href="def_s_c66_8h_source.html#l00072">72</a> of file <a class="el" href="def_s_c66_8h_source.html">defSC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_strmm_8c_source.html#l00137">arrangeDataLAStrmm()</a>, <a class="el" href="data_move_strsm_8c_source.html#l00266">arrangeDataLAStrsm()</a>, <a class="el" href="data_move_strmm_8c_source.html#l00043">arrangeDataUAStrmm()</a>, and <a class="el" href="data_move_strsm_8c_source.html#l00184">arrangeDataUAStrsm()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1cb780051c1f24665e315024e5879df0"></a><!-- doxytag: member="defZC66.h::MPARTITION_Z" ref="ga1cb780051c1f24665e315024e5879df0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPARTITION_Z&#160;&#160;&#160;(NUMAPANELS_Z*M_KERNEL_Z)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>partition in m dimension for double precision complex (MPARTITION_Z &lt;= KPARTITION_Z) </p>

<p>Definition at line <a class="el" href="def_z_c66_8h_source.html#l00072">72</a> of file <a class="el" href="def_z_c66_8h_source.html">defZC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_ztrmm_8c_source.html#l00143">arrangeDataLAZtrmm()</a>, <a class="el" href="data_move_ztrsm_8c_source.html#l00153">arrangeDataLAZtrsm()</a>, <a class="el" href="data_move_ztrmm_8c_source.html#l00045">arrangeDataUAZtrmm()</a>, and <a class="el" href="data_move_ztrsm_8c_source.html#l00043">arrangeDataUAZtrsm()</a>.</p>

</div>
</div>
<a class="anchor" id="ga416d1673ae180f28ea78c1542381ac6f"></a><!-- doxytag: member="defCC66.h::N_KERNEL_C" ref="ga416d1673ae180f28ea78c1542381ac6f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define N_KERNEL_C&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of columns to process by core kernel for single precision complex </p>

<p>Definition at line <a class="el" href="def_c_c66_8h_source.html#l00054">54</a> of file <a class="el" href="def_c_c66_8h_source.html">defCC66.h</a>.</p>

<p>Referenced by <a class="el" href="ctrsm_kernel_8c_source.html#l00047">ctrsmKernel()</a>.</p>

</div>
</div>
<a class="anchor" id="ga571fb3d37c3c42b647fc792408c9de2a"></a><!-- doxytag: member="defDC66.h::N_KERNEL_D" ref="ga571fb3d37c3c42b647fc792408c9de2a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define N_KERNEL_D&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of columns to process by core kernel for double precision </p>

<p>Definition at line <a class="el" href="def_d_c66_8h_source.html#l00054">54</a> of file <a class="el" href="def_d_c66_8h_source.html">defDC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_dgemm_8c_source.html#l00067">dataMoveBDgemm()</a>, <a class="el" href="data_move_dgemm_8c_source.html#l00043">dataMoveBTDgemm()</a>, and <a class="el" href="dtrsm_kernel_8c_source.html#l00048">dtrsmKernel()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf8005c932c5f5766135ad3f806e2ca81"></a><!-- doxytag: member="defSC66.h::N_KERNEL_S" ref="gaf8005c932c5f5766135ad3f806e2ca81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define N_KERNEL_S&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of columns to process by core kernel for single precision </p>

<p>Definition at line <a class="el" href="def_s_c66_8h_source.html#l00054">54</a> of file <a class="el" href="def_s_c66_8h_source.html">defSC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_sgemm_8c_source.html#l00071">dataMoveBSgemm()</a>, <a class="el" href="data_move_sgemm_8c_source.html#l00043">dataMoveBTSgemm()</a>, and <a class="el" href="strsm_kernel_8c_source.html#l00046">strsmKernel()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ca6f1ec823382afb58afa4da1ecbc77"></a><!-- doxytag: member="defZC66.h::N_KERNEL_Z" ref="ga5ca6f1ec823382afb58afa4da1ecbc77" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define N_KERNEL_Z&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of columns to process by core kernel for double precision complex </p>

<p>Definition at line <a class="el" href="def_z_c66_8h_source.html#l00054">54</a> of file <a class="el" href="def_z_c66_8h_source.html">defZC66.h</a>.</p>

<p>Referenced by <a class="el" href="ztrsm_kernel_8c_source.html#l00049">ztrsmKernel()</a>.</p>

</div>
</div>
<a class="anchor" id="ga82e046a41a629a2d622315ce11d8af2a"></a><!-- doxytag: member="defCC66.h::NPARTITION_C" ref="ga82e046a41a629a2d622315ce11d8af2a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NPARTITION_C&#160;&#160;&#160;(NUMBPANELS_C*N_KERNEL_C)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>partition in n dimension for single precision complex </p>

<p>Definition at line <a class="el" href="def_c_c66_8h_source.html#l00076">76</a> of file <a class="el" href="def_c_c66_8h_source.html">defCC66.h</a>.</p>

<p>Referenced by <a class="el" href="ctrsm_kernel_8c_source.html#l00047">ctrsmKernel()</a>, <a class="el" href="data_move_cgemm_8c_source.html#l00044">dataMoveBHCgemm()</a>, and <a class="el" href="data_move_cgemm_8c_source.html#l00069">dataMoveBTCgemm()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ac559036bc7631c0d691bc399151b77"></a><!-- doxytag: member="defDC66.h::NPARTITION_D" ref="ga5ac559036bc7631c0d691bc399151b77" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NPARTITION_D&#160;&#160;&#160;(NUMBPANELS_D*N_KERNEL_D)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>partition in n dimension for double precision </p>

<p>Definition at line <a class="el" href="def_d_c66_8h_source.html#l00076">76</a> of file <a class="el" href="def_d_c66_8h_source.html">defDC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_dgemm_8c_source.html#l00043">dataMoveBTDgemm()</a>, and <a class="el" href="dtrsm_kernel_8c_source.html#l00048">dtrsmKernel()</a>.</p>

</div>
</div>
<a class="anchor" id="ga663620ddec1ccb5d0c9ed5aa584bb473"></a><!-- doxytag: member="defSC66.h::NPARTITION_S" ref="ga663620ddec1ccb5d0c9ed5aa584bb473" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NPARTITION_S&#160;&#160;&#160;(NUMBPANELS_S*N_KERNEL_S)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>partition in n dimension for single precision </p>

<p>Definition at line <a class="el" href="def_s_c66_8h_source.html#l00076">76</a> of file <a class="el" href="def_s_c66_8h_source.html">defSC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_sgemm_8c_source.html#l00043">dataMoveBTSgemm()</a>, and <a class="el" href="strsm_kernel_8c_source.html#l00046">strsmKernel()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6b875b0eb12e72ecbd35c8824890652d"></a><!-- doxytag: member="defZC66.h::NPARTITION_Z" ref="ga6b875b0eb12e72ecbd35c8824890652d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NPARTITION_Z&#160;&#160;&#160;(NUMBPANELS_Z*N_KERNEL_Z)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>partition in n dimension for double precision complex </p>

<p>Definition at line <a class="el" href="def_z_c66_8h_source.html#l00076">76</a> of file <a class="el" href="def_z_c66_8h_source.html">defZC66.h</a>.</p>

<p>Referenced by <a class="el" href="data_move_zgemm_8c_source.html#l00043">dataMoveBHZgemm()</a>, <a class="el" href="data_move_zgemm_8c_source.html#l00061">dataMoveBTZgemm()</a>, and <a class="el" href="ztrsm_kernel_8c_source.html#l00049">ztrsmKernel()</a>.</p>

</div>
</div>
<a class="anchor" id="gab6eb83c9d6fd9fa003cdb33912d14231"></a><!-- doxytag: member="defCC66.h::NUMAPANELS_C" ref="gab6eb83c9d6fd9fa003cdb33912d14231" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUMAPANELS_C&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of panels of A to keep in MCMS/L2 for single precision complex </p>

<p>Definition at line <a class="el" href="def_c_c66_8h_source.html#l00063">63</a> of file <a class="el" href="def_c_c66_8h_source.html">defCC66.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafb96d4ad03ff2ff1a4d020d9323a9d96"></a><!-- doxytag: member="defDC66.h::NUMAPANELS_D" ref="gafb96d4ad03ff2ff1a4d020d9323a9d96" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUMAPANELS_D&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of panels of A to keep in MCMS/L2 for double precision </p>

<p>Definition at line <a class="el" href="def_d_c66_8h_source.html#l00063">63</a> of file <a class="el" href="def_d_c66_8h_source.html">defDC66.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga95cdd25ea213530aacecb0ae4c06da39"></a><!-- doxytag: member="defSC66.h::NUMAPANELS_S" ref="ga95cdd25ea213530aacecb0ae4c06da39" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUMAPANELS_S&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of panels of A to keep in MCMS/L2 for single precision </p>

<p>Definition at line <a class="el" href="def_s_c66_8h_source.html#l00063">63</a> of file <a class="el" href="def_s_c66_8h_source.html">defSC66.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga27697f4b514d4af26ad2fa0071a984de"></a><!-- doxytag: member="defZC66.h::NUMAPANELS_Z" ref="ga27697f4b514d4af26ad2fa0071a984de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUMAPANELS_Z&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of panels of A to keep in MCMS/L2 for double precision complex </p>

<p>Definition at line <a class="el" href="def_z_c66_8h_source.html#l00063">63</a> of file <a class="el" href="def_z_c66_8h_source.html">defZC66.h</a>.</p>

</div>
</div>
<a class="anchor" id="gac631d3a0c661ca5048e4c4b49e349252"></a><!-- doxytag: member="defCC66.h::NUMBPANELS_C" ref="gac631d3a0c661ca5048e4c4b49e349252" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUMBPANELS_C&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of panels of B to keep in MCMS for single precision complex </p>

<p>Definition at line <a class="el" href="def_c_c66_8h_source.html#l00067">67</a> of file <a class="el" href="def_c_c66_8h_source.html">defCC66.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga99b8c99ea3d396d9a2e36fbc4c8827f4"></a><!-- doxytag: member="defDC66.h::NUMBPANELS_D" ref="ga99b8c99ea3d396d9a2e36fbc4c8827f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUMBPANELS_D&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of panels of B to keep in MCMS for double precision </p>

<p>Definition at line <a class="el" href="def_d_c66_8h_source.html#l00067">67</a> of file <a class="el" href="def_d_c66_8h_source.html">defDC66.h</a>.</p>

</div>
</div>
<a class="anchor" id="gababf10a8a7298c7d2c8729fef5f4168b"></a><!-- doxytag: member="defSC66.h::NUMBPANELS_S" ref="gababf10a8a7298c7d2c8729fef5f4168b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUMBPANELS_S&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of panels of B to keep in MCMS for single precision </p>

<p>Definition at line <a class="el" href="def_s_c66_8h_source.html#l00067">67</a> of file <a class="el" href="def_s_c66_8h_source.html">defSC66.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga27ecd772a7f65be627d40f1ce7bf28e1"></a><!-- doxytag: member="defZC66.h::NUMBPANELS_Z" ref="ga27ecd772a7f65be627d40f1ce7bf28e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUMBPANELS_Z&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>number of panels of B to keep in MCMS for double precision complex </p>

<p>Definition at line <a class="el" href="def_z_c66_8h_source.html#l00067">67</a> of file <a class="el" href="def_z_c66_8h_source.html">defZC66.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga8df722b37944c5219054285fc703721e"></a><!-- doxytag: member="cgemmKernel.h::cgemmKernel" ref="ga8df722b37944c5219054285fc703721e" args="(const complex *pA, const complex *pB, complex *pC, const complex a, const int k, const int stepC)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgemmKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stepC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Core matrix multiplication routine; performs C += a*A*B. A is 2xk matrix of complex numbers; B is kx4 matrix of complex numbers; a is scalar multiplicative constant; C is 2x4 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pA</td><td>Pointer to matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pB</td><td>Pointer to matrix B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pC</td><td>Pointer to matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>length of matrices (A is 2xk and B is kx4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>scalar multiplicative constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepC</td><td>number of elements to skip to write the next column in C </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cgemm_kernel_8c_source.html#l00048">48</a> of file <a class="el" href="cgemm_kernel_8c_source.html">cgemmKernel.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab0a20f8becde0a9becdc4c175983baee"></a><!-- doxytag: member="cgemmKernel.h::cgemmKernelFlexSave" ref="gab0a20f8becde0a9becdc4c175983baee" args="(const complex *pA, const complex *pB, complex *pC, const complex a, const int k, const int stepC, const int saveLoc, const int flagisN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgemmKernelFlexSave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stepC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>saveLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flagisN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Core matrix multiplication routine; performs C += a*A*B. This particular functions flexible saving of the 2 x 4 output. It can save as 4 x 2 transposed output. In addition, it can also save only the lower/upper triangular part of the output. A is 2xk matrix of complex numbers; B is kx4 matrix of complex numbers; a is scalar multiplicative constant; C is 2x4 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pA</td><td>Pointer to matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pB</td><td>Pointer to matrix B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pC</td><td>Pointer to matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>length of matrices (A is 2xk and B is kx4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>scalar multiplicative constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepC</td><td>number of elements to skip to write the next column in C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveLoc</td><td>location from where the triangular parts needs to be saved. A value of zero indicates upper left corner. A negative value indicate part of the matrix below the upper left corner and positive value indicates part of the matrix right of upper left corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagisN</td><td>flag to indicate if C is saved in normal form or transposed form. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cgemm_kernel_8c_source.html#l00213">213</a> of file <a class="el" href="cgemm_kernel_8c_source.html">cgemmKernel.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaee93ce96268d4b0247f234b44de51a19"></a><!-- doxytag: member="cgemmKernel.h::cgemmKernelNoReadFlexSave" ref="gaee93ce96268d4b0247f234b44de51a19" args="(const complex *pA, const complex *pB, complex *pC, const complex a, const int k, const int stepC, const int saveLoc, const int flagisN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cgemmKernelNoReadFlexSave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stepC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>saveLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flagisN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Core matrix multiplication routine; performs C = a*A*B. This particular functions flexible saving of the 2 x 4 output. It can save as 4 x 2 transposed output. In addition, it can also save only the lower/upper triangular part of the output. This variation of the kernel do not read from C. A is 2xk matrix of complex numbers; B is kx4 matrix of complex numbers; a is scalar multiplicative constant; C is 2x4 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pA</td><td>Pointer to matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pB</td><td>Pointer to matrix B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pC</td><td>Pointer to matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>length of matrices (A is 2xk and B is kx4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>scalar multiplicative constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepC</td><td>number of elements to skip to write the next column in C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveLoc</td><td>location from where the triangular parts needs to be saved. A value of zero indicates upper left corner. A negative value indicate part of the matrix below the upper left corner and positive value indicates part of the matrix right of upper left corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagisN</td><td>flag to indicate if C is saved in normal form or transposed form. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="cgemm_kernel_8c_source.html#l00752">752</a> of file <a class="el" href="cgemm_kernel_8c_source.html">cgemmKernel.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga5554cbae0ad254ae6d3cb38e06e38d15"></a><!-- doxytag: member="ctrsmKernel.h::ctrsmKernel" ref="ga5554cbae0ad254ae6d3cb38e06e38d15" args="(const complex *pA, complex *pB, complex *pC, complex *pBHat, const int k, const int stepC, const int flagisN, const int flagisL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ctrsmKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplex.html">complex</a> *&#160;</td>
          <td class="paramname"><em>pBHat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stepC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flagisN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flagisL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Core traingular matrix inversionroutine; First performs C += A*B either to or from followed by C=A^{-1}(2,2)*B. That is it accumulates the necessary C and finalluy performs inverse multiplications by a 2x2 matrix. The 2x2 matrix was already inverted in the data movement routine and hence. This kernel only performs the multplications. The multiplication can be pre or post depending on whether we are saving the transpose form of the output or not. Also note that the inverted matrix can be lower or upper triangular. A is 2xk matrix of complex numbers; B os kx4 matrix of complex numbers; C is 2x4 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pA</td><td>Pointer to matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pB</td><td>Pointer to matrix B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBHat</td><td>Pointer to intermediate matrix B if used </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pC</td><td>Pointer to matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>length of matrices (A is 2xk and B is kx4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepC</td><td>number of elements to skip to write the next column in C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagisN</td><td>flag to indicate if C is saved in normal form or transposed form. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagisL</td><td>flag to indicate if A is in upper or lower triangular format. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ctrsm_kernel_8c_source.html#l00047">47</a> of file <a class="el" href="ctrsm_kernel_8c_source.html">ctrsmKernel.c</a>.</p>

<p>References <a class="el" href="def_c_c66_8h_source.html#l00059">KPARTITION_C</a>, <a class="el" href="def_c_c66_8h_source.html#l00050">M_KERNEL_C</a>, <a class="el" href="def_c_c66_8h_source.html#l00054">N_KERNEL_C</a>, and <a class="el" href="def_c_c66_8h_source.html#l00076">NPARTITION_C</a>.</p>

</div>
</div>
<a class="anchor" id="ga55c79885a68afa248c5ed80508f6e447"></a><!-- doxytag: member="dgemmKernel.h::dgemmKernel" ref="ga55c79885a68afa248c5ed80508f6e447" args="(const double *pA, const double *pB, double *pC, const double a, const int k, const int stepC)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dgemmKernel </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stepC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Core matrix multiplication routine; performs C += a*A*B. A is 4xk matrix of doubles; B is kx4 matrix of doubles; a is scalar multiplicative constant; C is 4x4 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pA</td><td>Pointer to matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pB</td><td>Pointer to matrix B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pC</td><td>Pointer to matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>length of matrices (A is 4xk and B is kx4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>scalar multiplicative constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepC</td><td>number of elements to skip to write the next column in C </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dgemm_kernel_8c_source.html#l00046">46</a> of file <a class="el" href="dgemm_kernel_8c_source.html">dgemmKernel.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga24187bdb447e6f5b0918e72d2faed86a"></a><!-- doxytag: member="dgemmKernel.h::dgemmKernelFlexSave" ref="ga24187bdb447e6f5b0918e72d2faed86a" args="(const double *pA, const double *pB, double *pC, const double a, const int k, const int stepC, const int saveLoc, const int flagisN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dgemmKernelFlexSave </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stepC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>saveLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flagisN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Core matrix multiplication routine; performs C += a*A*B. This particular functions flexible saving of the 4 x 4 output. It can save as 4 x 4 transposed output. In addition, it can also save only the lower/upper triangular part of the output. A is 4xk matrix of doubles; B is kx4 matrix of doubles; a is scalar multiplicative constant; C is 4x4 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pA</td><td>Pointer to matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pB</td><td>Pointer to matrix B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pC</td><td>Pointer to matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>length of matrices (A is 4xk and B is kx4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>scalar multiplicative constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepC</td><td>number of elements to skip to write the next column in C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveLoc</td><td>location from where the triangular parts needs to be saved. A value of zero indicates upper left corner. A negative value indicate part of the matrix below the upper left corner and positive value indicates part of the matrix right of upper left corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagisN</td><td>flag to indicate if C is saved in normal form or transposed form. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dgemm_kernel_8c_source.html#l00170">170</a> of file <a class="el" href="dgemm_kernel_8c_source.html">dgemmKernel.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab5d13df050308fd6863f44a09ee2f234"></a><!-- doxytag: member="dgemmKernel.h::dgemmKernelNoReadFlexSave" ref="gab5d13df050308fd6863f44a09ee2f234" args="(const double *pA, const double *pB, double *pC, const double a, const int k, const int stepC, const int saveLoc, const int flagisN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dgemmKernelNoReadFlexSave </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stepC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>saveLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flagisN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Core matrix multiplication routine; performs C = a*A*B. This particular functions flexible saving of the 4 x 4 output. It can save as 4 x 4 transposed output. In addition, it can also save only the lower/upper triangular part of the output. This variation of the kernel do not read from C. A is 4xk matrix of doubles; B is kx4 matrix of doubles; a is scalar multiplicative constant; C is 4x4 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pA</td><td>Pointer to matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pB</td><td>Pointer to matrix B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pC</td><td>Pointer to matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>length of matrices (A is 4xk and B is kx4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>scalar multiplicative constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepC</td><td>number of elements to skip to write the next column in C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveLoc</td><td>location from where the triangular parts needs to be saved. A value of zero indicates upper left corner. A negative value indicate part of the matrix below the upper left corner and positive value indicates part of the matrix right of upper left corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagisN</td><td>flag to indicate if C is saved in normal form or transposed form. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dgemm_kernel_8c_source.html#l00485">485</a> of file <a class="el" href="dgemm_kernel_8c_source.html">dgemmKernel.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaddf8875bd5fffbffbe5f3a579cd8e00e"></a><!-- doxytag: member="dtrsmKernel.h::dtrsmKernel" ref="gaddf8875bd5fffbffbe5f3a579cd8e00e" args="(const double *pA, double *pB, double *pC, double *pBHat, const int k, const int stepC, const int flagisN, const int flagisL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dtrsmKernel </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pBHat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stepC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flagisN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flagisL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Core traingular matrix inversionroutine; First performs C += A*B either to or from followed by C=A^{-1}(4,4)*B. That is it accumulates the necessary C and finalluy performs inverse multiplications by a 4x4 matrix. The 4x4 matrix was already inverted in the data movement routine and hence. This kernel only performs the multplications. The multiplication can be pre or post depending on whether we are saving the transpose form of the output or not. Also note that the inverted matrix can be lower or upper triangular. A is 4xk matrix of reals; B os kx4 matrix of reals; C is 4x4 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pA</td><td>Pointer to matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pB</td><td>Pointer to matrix B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBHat</td><td>Pointer to intermediate matrix B if used </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pC</td><td>Pointer to matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>length of matrices (A is 4xk and B is kx4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepC</td><td>number of elements to skip to write the next column in C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagisN</td><td>flag to indicate if C is saved in normal form or transposed form. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagisL</td><td>flag to indicate if A is in upper or lower triangular format. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="dtrsm_kernel_8c_source.html#l00048">48</a> of file <a class="el" href="dtrsm_kernel_8c_source.html">dtrsmKernel.c</a>.</p>

<p>References <a class="el" href="def_d_c66_8h_source.html#l00059">KPARTITION_D</a>, <a class="el" href="def_d_c66_8h_source.html#l00050">M_KERNEL_D</a>, <a class="el" href="def_d_c66_8h_source.html#l00054">N_KERNEL_D</a>, and <a class="el" href="def_d_c66_8h_source.html#l00076">NPARTITION_D</a>.</p>

</div>
</div>
<a class="anchor" id="gabcbb885da92272bf4838e80fe70fe9bc"></a><!-- doxytag: member="sgemmKernel.h::sgemmKernel" ref="gabcbb885da92272bf4838e80fe70fe9bc" args="(const real *pA, const real *pB, real *pC, const real a, const int k, const int stepC)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgemmKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stepC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Core matrix multiplication routine; performs C += a*A*B. A is 4xk matrix of reals; B is kx8 matrix of reals; a is scalar multiplicative constant; C is 4x8 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pA</td><td>Pointer to matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pB</td><td>Pointer to matrix B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pC</td><td>Pointer to matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>length of matrices (A is 4xk and B is kx8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>scalar multiplicative constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepC</td><td>number of elements to skip to write the next column in C </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sgemm_kernel_8c_source.html#l00048">48</a> of file <a class="el" href="sgemm_kernel_8c_source.html">sgemmKernel.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8a09abfb6e1e1c12b71d604a86324184"></a><!-- doxytag: member="sgemmKernel.h::sgemmKernelFlexSave" ref="ga8a09abfb6e1e1c12b71d604a86324184" args="(const real *pA, const real *pB, real *pC, const real a, const int k, const int stepC, const int saveLoc, const int flagisN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgemmKernelFlexSave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stepC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>saveLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flagisN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Core matrix multiplication routine; performs C += a*A*B. This particular functions flexible saving of the 4 x 8 output. It can save as 8 x 4 transposed output. In addition, it can also save only the lower/upper triangular part of the output. A is 4xk matrix of reals; B is kx8 matrix of reals; a is scalar multiplicative constant; C is 4x8 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pA</td><td>Pointer to matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pB</td><td>Pointer to matrix B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pC</td><td>Pointer to matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>length of matrices (A is 4xk and B is kx8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>scalar multiplicative constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepC</td><td>number of elements to skip to write the next column in C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveLoc</td><td>location from where the triangular parts needs to be saved. A value of zero indicates upper left corner. A negative value indicate part of the matrix below the upper left corner and positive value indicates part of the matrix right of upper left corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagisN</td><td>flag to indicate if C is saved in normal form or transposed form. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sgemm_kernel_8c_source.html#l00236">236</a> of file <a class="el" href="sgemm_kernel_8c_source.html">sgemmKernel.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae3c3e56093f7526255e4be710216030c"></a><!-- doxytag: member="sgemmKernel.h::sgemmKernelNoReadFlexSave" ref="gae3c3e56093f7526255e4be710216030c" args="(const real *pA, const real *pB, real *pC, const real a, const int k, const int stepC, const int saveLoc, const int flagisN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgemmKernelNoReadFlexSave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stepC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>saveLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flagisN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Core matrix multiplication routine; performs C = a*A*B. This particular functions flexible saving of the 4 x 8 output. It can save as 8 x 4 transposed output. In addition, it can also save only the lower/upper triangular part of the output. This variation of the kernel do not read from C. A is 4xk matrix of reals; B is kx8 matrix of reals; a is scalar multiplicative constant; C is 4x8 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pA</td><td>Pointer to matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pB</td><td>Pointer to matrix B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pC</td><td>Pointer to matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>length of matrices (A is 4xk and B is kx8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>scalar multiplicative constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepC</td><td>number of elements to skip to write the next column in C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveLoc</td><td>location from where the triangular parts needs to be saved. A value of zero indicates upper left corner. A negative value indicate part of the matrix below the upper left corner and positive value indicates part of the matrix right of upper left corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagisN</td><td>flag to indicate if C is saved in normal form or transposed form. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sgemm_kernel_8c_source.html#l00834">834</a> of file <a class="el" href="sgemm_kernel_8c_source.html">sgemmKernel.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga27623ba25b81fef7c11883d4c25bb929"></a><!-- doxytag: member="strsmKernel.h::strsmKernel" ref="ga27623ba25b81fef7c11883d4c25bb929" args="(const real *pA, real *pB, real *pC, real *pBHat, const int k, const int stepC, const int flagisN, const int flagisL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void strsmKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__c66params.html#ga031f8951175b43076c2084a6c2173410">real</a> *&#160;</td>
          <td class="paramname"><em>pBHat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stepC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flagisN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flagisL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Core traingular matrix inversionroutine; First performs C += A*B either to or from followed by C=A^{-1}(4,4)*B. That is it accumulates the necessary C and finalluy performs inverse multiplications by a 4x4 matrix. The 4x4 matrix was already inverted in the data movement routine and hence. This kernel only performs the multplications. The multiplication can be pre or post depending on whether we are saving the transpose form of the output or not. Also note that the inverted matrix can be lower or upper triangular. A is 4xk matrix of reals; B os kx8 matrix of reals; C is 4x8 matrix; It is actually a sub-matrix of larger marger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pA</td><td>Pointer to matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pB</td><td>Pointer to matrix B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBHat</td><td>Pointer to intermediate matrix B if used </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pC</td><td>Pointer to matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>length of matrices (A is 4xk and B is kx8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepC</td><td>number of elements to skip to write the next column in C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagisN</td><td>flag to indicate if C is saved in normal form or transposed form. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagisL</td><td>flag to indicate if A is in upper or lower triangular format. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="strsm_kernel_8c_source.html#l00046">46</a> of file <a class="el" href="strsm_kernel_8c_source.html">strsmKernel.c</a>.</p>

<p>References <a class="el" href="def_s_c66_8h_source.html#l00059">KPARTITION_S</a>, <a class="el" href="def_s_c66_8h_source.html#l00050">M_KERNEL_S</a>, <a class="el" href="def_s_c66_8h_source.html#l00054">N_KERNEL_S</a>, and <a class="el" href="def_s_c66_8h_source.html#l00076">NPARTITION_S</a>.</p>

</div>
</div>
<a class="anchor" id="ga86dd34473d096e9004e2116edfc1371e"></a><!-- doxytag: member="zgemmKernel.h::zgemmKernel" ref="ga86dd34473d096e9004e2116edfc1371e" args="(const doublecomplex *pA, const doublecomplex *pB, doublecomplex *pC, const doublecomplex a, const int k, const int stepC)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zgemmKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdoublecomplex.html">doublecomplex</a> *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdoublecomplex.html">doublecomplex</a> *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdoublecomplex.html">doublecomplex</a> *&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdoublecomplex.html">doublecomplex</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stepC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Core matrix multiplication routine; performs C += a*A*B. A is 4xk matrix of doublecomplex numbers; B os kx8 matrix of doublecomplex numbers; a is scalar multiplicative constant; C is 4x8 matrix; It is actually a sub-matrix of larger marger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pA</td><td>Pointer to matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pB</td><td>Pointer to matrix B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pC</td><td>Pointer to matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>length of matrices (A is 4xk and B is kx8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>scalar muliplicative constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepC</td><td>number of elements to skip to write the next column in C </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="zgemm_kernel_8c_source.html#l00048">48</a> of file <a class="el" href="zgemm_kernel_8c_source.html">zgemmKernel.c</a>.</p>

<p>References <a class="el" href="def_c66_8h_source.html#l00059">doublecomplex::i</a>, and <a class="el" href="def_c66_8h_source.html#l00059">doublecomplex::r</a>.</p>

</div>
</div>
<a class="anchor" id="ga18c67e16636b6df862fe73275dd409b7"></a><!-- doxytag: member="zgemmKernel.h::zgemmKernelFlexSave" ref="ga18c67e16636b6df862fe73275dd409b7" args="(const doublecomplex *pA, const doublecomplex *pB, doublecomplex *pC, const doublecomplex a, const int k, const int stepC, const int saveLoc, const int flagisN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zgemmKernelFlexSave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdoublecomplex.html">doublecomplex</a> *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdoublecomplex.html">doublecomplex</a> *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdoublecomplex.html">doublecomplex</a> *&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdoublecomplex.html">doublecomplex</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stepC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>saveLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flagisN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Core matrix multiplication routine; performs C += a*A*B. This particular functions flexible saving of the 4 x 8 output. It can save as 8 x 4 transposed ouput. In addition, it can also save only the lower/upper traingular part of the output. A is 4xk matrix of doublecomplex numbers; B os kx8 matrix of doublecomplex numbers; a is scalar multiplicative constant; C is 4x8 matrix; It is actually a sub-matrix of larger marger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pA</td><td>Pointer to matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pB</td><td>Pointer to matrix B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pC</td><td>Pointer to matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>length of matrices (A is 4xk and B is kx8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>scalar muliplicative constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepC</td><td>number of elements to skip to write the next column in C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveLoc</td><td>location from where the trangular parts needs to be saved. A value of zero indicates upper left corner. A negative value indicate part of the matrix below the upper left corner and positive value indicates part of the matrix right of upper left corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagisN</td><td>flag to indicate if C is saved in normal form or transposed form. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="zgemm_kernel_8c_source.html#l00177">177</a> of file <a class="el" href="zgemm_kernel_8c_source.html">zgemmKernel.c</a>.</p>

<p>References <a class="el" href="def_c66_8h_source.html#l00059">doublecomplex::i</a>, and <a class="el" href="def_c66_8h_source.html#l00059">doublecomplex::r</a>.</p>

</div>
</div>
<a class="anchor" id="ga5b875b49e9822c689f8983d139f39e41"></a><!-- doxytag: member="zgemmKernel.h::zgemmKernelNoReadFlexSave" ref="ga5b875b49e9822c689f8983d139f39e41" args="(const doublecomplex *pA, const doublecomplex *pB, doublecomplex *pC, const doublecomplex a, const int k, const int stepC, const int saveLoc, const int flagisN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zgemmKernelNoReadFlexSave </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdoublecomplex.html">doublecomplex</a> *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdoublecomplex.html">doublecomplex</a> *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdoublecomplex.html">doublecomplex</a> *&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdoublecomplex.html">doublecomplex</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stepC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>saveLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flagisN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Core matrix multiplication routine; performs C = a*A*B. This particular functions flexible saving of the 4 x 8 output. It can save as 8 x 4 transposed ouput. In addition, it can also save only the lower/upper traingular part of the output. This variation of the kernel do not read from C. A is 4xk matrix of doublecomplex numbers; B os kx8 matrix of doublecomplex numbers; a is scalar multiplicative constant; C is 4x8 matrix; It is actually a sub-matrix of larger marger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major C will be saved as column major. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pA</td><td>Pointer to matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pB</td><td>Pointer to matrix B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pC</td><td>Pointer to matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>length of matrices (A is 4xk and B is kx8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>scalar muliplicative constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepC</td><td>number of elements to skip to write the next column in C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saveLoc</td><td>location from where the trangular parts needs to be saved. A value of zero indicates upper left corner. A negative value indicate part of the matrix below the upper left corner and positive value indicates part of the matrix right of upper left corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagisN</td><td>flag to indicate if C is saved in normal form or transposed form. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="zgemm_kernel_8c_source.html#l00315">315</a> of file <a class="el" href="zgemm_kernel_8c_source.html">zgemmKernel.c</a>.</p>

<p>References <a class="el" href="def_c66_8h_source.html#l00059">doublecomplex::i</a>, and <a class="el" href="def_c66_8h_source.html#l00059">doublecomplex::r</a>.</p>

</div>
</div>
<a class="anchor" id="gaf99350e21fb4fd8e5486fb9be9b79564"></a><!-- doxytag: member="ztrsmKernel.h::ztrsmKernel" ref="gaf99350e21fb4fd8e5486fb9be9b79564" args="(const doublecomplex *pA, doublecomplex *pB, doublecomplex *pC, doublecomplex *pBHat, const int k, const int stepC, const int flagisN, const int flagisL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ztrsmKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdoublecomplex.html">doublecomplex</a> *&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdoublecomplex.html">doublecomplex</a> *&#160;</td>
          <td class="paramname"><em>pB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdoublecomplex.html">doublecomplex</a> *&#160;</td>
          <td class="paramname"><em>pC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdoublecomplex.html">doublecomplex</a> *&#160;</td>
          <td class="paramname"><em>pBHat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stepC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flagisN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>flagisL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Core traingular matrix inversionroutine; First performs C += A*B either to or from followed by C=A^{-1}(1,1)*B. That is it accumulates the necessary C and finalluy performs inverse multiplications by a 1x1 matrix. The 1x1 matrix was already inverted in the data movement routine and hence. This kernel only performs the multplications. The multiplication can be pre or post depending on whether we are saving the transpose form of the output or not. Also note that the inverted matrix can be lower or upper triangular. A is 1xk matrix of complex numbers; B os kx1 matrix of complex numbers; C is 1x1 matrix; It is actually a sub-matrix of larger matrix; the number of columns in original C is stepC; stepC thus indicates the number of elements to skip to write the next column. A is assumed to be stored in column major B is assumed to be stored in row major. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pA</td><td>Pointer to matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pB</td><td>Pointer to matrix B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBHat</td><td>Pointer to intermediate matrix B if used </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pC</td><td>Pointer to matrix C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>length of matrices (A is 1xk and B is kx1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepC</td><td>number of elements to skip to write the next column in C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagisN</td><td>flag to indicate if C is saved in normal form or transposed form. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flagisL</td><td>flag to indicate if A is in upper or lower triangular format. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ztrsm_kernel_8c_source.html#l00049">49</a> of file <a class="el" href="ztrsm_kernel_8c_source.html">ztrsmKernel.c</a>.</p>

<p>References <a class="el" href="def_z_c66_8h_source.html#l00050">M_KERNEL_Z</a>, <a class="el" href="def_z_c66_8h_source.html#l00054">N_KERNEL_Z</a>, and <a class="el" href="def_z_c66_8h_source.html#l00076">NPARTITION_Z</a>.</p>

</div>
</div>
</div>
<hr size="1"><small>
Copyright  2012, Texas Instruments Incorporated</small>
</body>
</html>
