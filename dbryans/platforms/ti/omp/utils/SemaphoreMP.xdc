/* --COPYRIGHT--,BSD
 * Copyright (c)  2012, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * --/COPYRIGHT--*/
/*
 *  ======== SemaphoreMP.xdc ========
 */

package ti.omp.utils;

import xdc.runtime.Assert;
import xdc.rov.ViewInfo;

import ti.sysbios.knl.Task;

import ti.sdo.ipc.SharedRegion;
import ti.sdo.ipc.GateMP;
import ti.sdo.ipc.Ipc;
import ti.sdo.ipc.ListMP;
import ti.sdo.utils.NameServer;

/*!
 *  ======== SemaphoreMP ========
 *  MP-capable semaphore
 */

@InstanceInitError
@InstanceFinalize

module SemaphoreMP
{
    /*! Types of semaphores. */
    enum Mode {
        Mode_COUNTING,  /*! Counting semaphore. */
        Mode_BINARY     /*! Binary Semaphore. */
    };

    /*! @_nodoc */
    metaonly struct BasicView {
        String      name;
        String      objType;
        Ptr         gate;
        String      mode;
        UInt        count;
        String      pendedTasks[];
    };
    
    /*! @_nodoc */
    @Facet
    metaonly config ViewInfo.Instance rovViewInfo =
        ViewInfo.create({
            viewMap: [
            [   
                'Basic',
                {
                    type: ViewInfo.INSTANCE,
                    viewInitFxn: 'viewInitBasic',
                    structName: 'BasicView'
                }
            ],
            ]
        });
    
    /*! 
     *  Generated by {@link #pend} if BIOS_EVENT_ACQUIRED timeout is used
     *  with a Semaphore that has not been configured with an Event object
     */
    config Assert.Id A_invTimeout = {
        msg: "A_invTimeout: Can't use BIOS_EVENT_ACQUIRED with this Semaphore."
    };

    /*!
     * Asserted when {@link #pend} is called with non-zero timeout from other
     * than a Task context.
     */
    config Assert.Id A_badContext = {
        msg: "A_badContext: bad calling context. Must be called from a Task."
    };
    
    /*!
     *  ======== notifyEventId ========
     *  The Notify event ID.
     */
    config UInt notifyEventId = 6;
    
    /*!
     *  ======== open ========
     */
    Int open(String name, Handle *handlePtr);

    /*! @_nodoc
     *  ======== openByAddr ========
     */
    Int openByAddr(Ptr sharedAddr, Handle *handlePtr);

    
    /*!
     *  ======== close ========
     */
    Void close(Handle *handle);

    
    /*! @_nodoc
     *  ======== sharedMemReq ========
     *  Amount of shared memory required for creation of each instance
     *
     *  The following parameters must be set before calling sharedMemReq:
     *  @p(blist)
     *  - {@link #regionId} or {@link #sharedAddr}
     *  @p
     *
     *  The {@link #regionId} or {@link #sharedAddr} needs to be
     *  supplied because the cache alignment settings for the region
     *  may affect the total amount of shared memory required.
     *
     *  @param(params)      Pointer to the parameters that will be used in
     *                      the create.
     *
     *  @a(returns)         Number of MAUs needed to create the instance.
     */
    SizeT sharedMemReq(const Params *params);

    /* @_nodoc */
    Void start();
    
    /*! 
     *  ======== maxRuntimeEntries ========
     *  Maximum number of ListMP's that can be dynamically created
     *  and added to the NameServer.
     */
    metaonly config UInt maxRuntimeEntries = NameServer.ALLOWGROWTH; 

    /*!
     *  ======== maxNameLen ========
     *  Maximum length for names.
     */
    metaonly config UInt maxNameLen = 32;

    /*!
     *  ======== tableSection ========
     *  Section name is used to place the names table
     */
    metaonly config String tableSection = null;

instance:

    /*!
     *  ======== create ========
     *  Create a SemaphoreMP instance.
     *
     *  This function creates a new Semaphore instance which is initialized to
     *  count.
     *
     *  @param(count)                   Initial semaphore count
     */
    create(Int count);
    
    /*!
     *  ======== getCount ========
     *  Get current semaphore count.
     *
     *  This function returns the current value of the semaphore specified by
     *  the handle.
     *
     *  @b(returns)             current semaphore count
     */
    @DirectCall 
    Int getCount();

    /*!
     *  ======== pend ========
     *  Wait for a semaphore.
     *
     *  @b(returns)                     TRUE if successful, FALSE if timeout
     */
    @DirectCall 
    Bool pend();

    /*!
     *  ======== post ========
     *  Signal a semaphore.
     *
     *  Readies the first task waiting for the semaphore. If no task is
     *  waiting, This function simply increments the semaphore count and returns
     *  In case of binary semaphore the count has a maximum value of one.
     */
    @DirectCall 
    Void post();

    /*!
     *  ======== reset ========
     *  @_nodoc
     *  Reset semaphore count.
     *
     *  Resets the semaphore count to count.
     *
     *  @param(count)                   semaphore count
     *
     */
    @DirectCall 
    Void reset();
    
    /*!
     *  ======== mode ========
     *  Semaphore mode. Default is COUNTING.
     *
     *  When mode is BINARY , the semaphore has only two states, available
     *  and unavailable. When mode is COUNTING, the semaphore keeps track of
     *  number of times a semaphore is posted.
     */
    config Mode mode = Mode_COUNTING;
    
    /*! 
     *  ======== gate ========
     *  GateMP used for critical region management of the shared memory 
     *
     *  Using the default value of NULL will result in the default GateMP
     *  being used for context protection.
     */
    config GateMP.Handle gate = null; 
    
    /*! @_nodoc
     *  ======== openFlag ========
     *  Set to 'true' by the {@link #open}.
     */
    config Bool openFlag = false;

    /*! @_nodoc
     *  ======== sharedAddr ========
     *  Physical address of the shared memory
     *
     *  The shared memory that will be used for maintaining shared state
     *  information.  This is an optional parameter to create.  If value
     *  is null, then the shared memory for the new instance will be
     *  allocated from the heap in {@link #regionId}.
     */
    config Ptr sharedAddr = null;
    
    /*!
     *  ======== name ========
     *  Name of the instance
     *
     *  The name must be unique among all SemaphoreMP instances in the sytem.
     *  When using {@link regionId} to create a new instance, the name must
     *  not be null.
     */
    config String name = null;
    
    /*! 
     *  ======== regionId ========
     *  SharedRegion ID.
     *
     *  The ID corresponding to the index of the shared region in which this
     *  shared instance is to be placed.  This is used in create() only when
     *  {@link #name} is not null.
     */
    config UInt16 regionId = 0;

internal:

    /*! Used in the attrs->status field */
    const UInt32 CREATED = 0xabcd1234;
    
    Void cbFxn(UInt16 procId, UInt16 lineId, UInt32 eventId, UArg arg, 
               UInt32 payload);
               
    Int registerEvent(UArg arg, UInt16 procId);

    /*!
     *  ======== nameSrvPrms ========
     *  This Params object is used for temporary storage of the
     *  module wide parameters that are for setting the NameServer instance.
     */
    metaonly config NameServer.Params nameSrvPrms;
    
    /*! Structure of attributes in shared memory */    
    struct Attrs {
        Bits32              status;
        SharedRegion.SRPtr  gateMPAddr;     /* GateMP SRPtr (shm safe)       */
        Bits16              count;          /* Semaphore count               */
        Bits16              mode;
    };
    
    /* Semaphore pendQ Element */
    struct PendElem {
        ListMP.Elem         elem;
        Bits16              procId;
        Bits32              task;
    };

    struct Instance_State {
        Attrs               *attrs;
        Mode                mode;           /* Binary or counting            */
        GateMP.Handle       gate;           /* Gate for critical regions     */
        Ipc.ObjType         objType;        /* See enum ObjType              */
        Ptr                 nsKey;          /* Used to remove NS entry       */
        Bool                cacheEnabled;   /* Whether to do cache calls     */
        UInt16              regionId;       /* SharedRegion index            */
        SizeT               allocSize;
        ListMP.Handle       pendQ;          /* queue of PendElems            */
	  UInt32   		    QMSS_sem_Hnd;   /* queue used for a QMSS lock mechanism            */
    };
    
    struct Module_State {
        NameServer.Handle   nameServer;     /* NameServer for this module    */
        ThreadLocal.Key     pendElemKey;
    };
}
